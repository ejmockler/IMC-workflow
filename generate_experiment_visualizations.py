"""
Script to generate experiment-level visualizations from the results of run_experiment_analysis.py.
"""
import yaml
import os
import sys
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt # Explicitly import for plot saving/closing
import traceback
from typing import Dict, Optional, List, Tuple

# Import necessary functions from the pipeline
# Assuming load_config might be slightly different or reused, define it here
# Need data loading/helper functions that might have been in run_experiment_analysis
from src.experiment_pipeline.data_aggregation import load_metadata
from src.experiment_pipeline.analysis_core import get_channel_columns # Reuse helper

# Import plotting functions
from src.experiment_pipeline.visualization import (
    plot_dendrogram,
    plot_heatmap_metacluster_profiles,
    plot_ordination,
    plot_abundance_trends_lineplot,
    plot_abundance_distribution_boxplot
)

# --- Configuration Loading (Adapted from main script) ---
def load_config(config_path: str = "config.yaml") -> Optional[Dict]:
    """Loads the pipeline configuration from a YAML file."""
    if not os.path.exists(config_path):
        print(f"ERROR: Configuration file not found at {config_path}")
        return None
    try:
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
        print(f"Configuration loaded successfully from: {config_path}")
        # Basic validation (add more specific checks if needed for vis)
        if not isinstance(config, dict):
            print(f"ERROR: Config file {config_path} is not a valid dictionary.")
            return None
        required_keys = ['paths', 'experiment_analysis', 'data', 'processing']
        if not all(key in config for key in required_keys):
            missing = [key for key in required_keys if key not in config]
            print(f"ERROR: Config file is missing required top-level keys: {missing}")
            return None
        print("Config basic validation passed.")
        return config
    except yaml.YAMLError as e:
        print(f"ERROR: Failed to parse configuration file {config_path}: {e}")
        return None
    except Exception as e:
        print(f"ERROR: An unexpected error occurred while loading configuration: {e}")
        return None


def generate_visualizations(config: Dict):
    """Loads analysis results and generates experiment-level plots."""
    print("\n--- Starting Experiment Visualization Generation ---")

    # --- Setup Paths ---
    base_output_dir = config.get('paths', {}).get('output_dir')
    exp_config = config.get('experiment_analysis', {})
    exp_subdir = exp_config.get('output_subdir', 'experiment_summary')
    analysis_output_dir = os.path.join(base_output_dir, exp_subdir) # Directory where analysis results are saved
    vis_output_dir = os.path.join(analysis_output_dir, "plots") # Subdirectory for plots generated by this script
    os.makedirs(vis_output_dir, exist_ok=True)
    print(f"Loading analysis results from: {analysis_output_dir}")
    print(f"Saving visualizations to: {vis_output_dir}")
    plot_dpi = config.get('processing', {}).get('plot_dpi', 150)


    # --- Load Metadata ---
    metadata_df = load_metadata(config)
    if metadata_df is None:
        print("ERROR: Failed to load metadata. Cannot generate plots requiring metadata.")
        # Decide if we can generate plots that don't need metadata? For now, exit.
        return

    # --- Determine if Meta-Clustering was performed ---
    # Check if meta-clustering output files exist
    clustered_profiles_path = os.path.join(analysis_output_dir, "aggregated_profiles_with_metaclusters.csv")
    linkage_path = os.path.join(analysis_output_dir, "metacluster_linkage_matrix.npy")
    avg_profiles_path = os.path.join(analysis_output_dir, "metacluster_average_profiles.csv")

    metaclustering_done = False
    if os.path.exists(clustered_profiles_path) and os.path.exists(linkage_path) and os.path.exists(avg_profiles_path):
         print("Meta-clustering results found. Will generate meta-cluster plots.")
         metaclustering_done = True
         grouping_col = 'meta_cluster'
    else:
         print("Meta-clustering results not found. Assuming analysis used original 'community' labels.")
         grouping_col = 'community'

    # --- Load Core Data required for plots ---
    clustered_profiles_df = None
    linkage_matrix_Z = None
    channel_cols = []
    composition_matrix = None

    # Load data specific to meta-clustering if it was done
    if metaclustering_done:
        try:
            clustered_profiles_df = pd.read_csv(clustered_profiles_path)
            linkage_matrix_Z = np.load(linkage_path)
            # Need channel_cols - get from the loaded profiles dataframe
            channel_cols = get_channel_columns(clustered_profiles_df, config)
            if not channel_cols:
                 print("ERROR: Could not determine channel columns from loaded clustered profiles.")
                 # Fallback or error? Maybe plots needing channels will fail.
        except Exception as e:
            print(f"ERROR loading meta-clustering results: {e}. Plots requiring these will be skipped.")
            metaclustering_done = False # Revert flag if loading failed
            grouping_col = 'community' # Revert grouping col

    # Load composition matrix (always needed for ordination)
    comp_matrix_filename = f"{grouping_col}_composition_matrix.csv"
    comp_matrix_path = os.path.join(analysis_output_dir, comp_matrix_filename)
    try:
        if os.path.exists(comp_matrix_path):
            composition_matrix = pd.read_csv(comp_matrix_path, index_col=0) # ROI is index
            print(f"Successfully loaded composition matrix from: {comp_matrix_filename}")
        else:
             print(f"ERROR: Composition matrix file not found: {comp_matrix_path}. Cannot generate ordination plot.")
    except Exception as e:
         print(f"ERROR loading composition matrix from {comp_matrix_path}: {e}")
         composition_matrix = None # Ensure it's None on error

    # --- Load Abundance Data ---
    abundance_summary_df = None
    abundance_filename = f"{grouping_col}_abundance_summary.csv"
    abundance_path = os.path.join(analysis_output_dir, abundance_filename)
    try:
        if os.path.exists(abundance_path):
            abundance_summary_df = pd.read_csv(abundance_path)
            print(f"Successfully loaded abundance summary from: {abundance_filename}")
        else:
            print(f"Warning: Abundance summary file not found: {abundance_path}. Cannot generate abundance plots.")
    except Exception as e:
        print(f"ERROR loading abundance summary from {abundance_path}: {e}")
        abundance_summary_df = None

    # --- Generate Plots ---

    # 1. Meta-cluster Dendrogram (if meta-clustering done)
    if metaclustering_done and linkage_matrix_Z is not None:
        print("\n--- Generating Meta-Cluster Dendrogram ---")
        dendro_path = os.path.join(vis_output_dir, "metacluster_dendrogram.png")
        try:
            plot_dendrogram(
                linkage_matrix_Z=linkage_matrix_Z,
                output_path=dendro_path,
                config=config,
                plot_dpi=plot_dpi,
                truncate_mode='lastp',
                p=30, show_leaf_counts=True
            )
            print(f"Dendrogram saved to: {dendro_path}")
            plt.close('all') # Close plot figure
        except Exception as e:
            print(f"ERROR generating dendrogram plot: {e}")
            traceback.print_exc()

    # 2. Meta-cluster Heatmap (if meta-clustering done)
    if metaclustering_done and clustered_profiles_df is not None and channel_cols:
        print("\n--- Generating Meta-Cluster Profile Heatmap ---")
        heatmap_path = os.path.join(vis_output_dir, "metacluster_profile_heatmap.png")
        try:
            plot_heatmap_metacluster_profiles(
                clustered_profiles_df=clustered_profiles_df,
                channel_cols=channel_cols,
                config=config,
                output_path=heatmap_path,
                scale_heatmap=True,
                plot_dpi=plot_dpi
            )
            print(f"Meta-cluster heatmap saved to: {heatmap_path}")
            plt.close('all') # Close plot figure
        except Exception as e:
            print(f"ERROR generating meta-cluster heatmap: {e}")
            traceback.print_exc()

    # 3. Ordination Plot
    if composition_matrix is not None and metadata_df is not None:
         print("\n--- Generating Ordination Plot ---")
         # Align metadata with the composition matrix index for plotting
         # Use 'roi_standard_key' as the reliable key added by load_metadata
         metadata_roi_key = 'roi_standard_key'
         if metadata_roi_key not in metadata_df.columns:
              print(f"ERROR: Metadata key '{metadata_roi_key}' not found in metadata. Cannot align for plotting.")
              aligned_metadata_for_plot = None
              composition_matrix_for_plot = None
         else:
              aligned_metadata_for_plot = None
              composition_matrix_for_plot = None # Initialize
              try:
                  # Ensure correct index type for alignment
                  metadata_indexed = metadata_df.set_index(metadata_roi_key)
                  # Ensure composition matrix index is treated as string if needed
                  composition_matrix.index = composition_matrix.index.astype(str)
                  metadata_indexed.index = metadata_indexed.index.astype(str)

                  # Align using intersection of indices
                  common_indices = composition_matrix.index.intersection(metadata_indexed.index)
                  if len(common_indices) < len(composition_matrix.index):
                      print(f"   Warning: {len(composition_matrix.index) - len(common_indices)} ROIs from composition matrix not found in metadata index. Dropping them.")
                  if len(common_indices) < 3:
                       print(f"   ERROR: Fewer than 3 overlapping ROIs ({len(common_indices)}) between composition and metadata. Cannot plot ordination.")
                  else:
                      aligned_metadata_for_plot = metadata_indexed.loc[common_indices]
                      composition_matrix_for_plot = composition_matrix.loc[common_indices]
                      print(f"   Aligned data for {len(common_indices)} ROIs for plotting.")

                      # Define essential plot columns from config for checking NA
                      hue_col_plot = exp_config.get('plot_hue_col', 'Condition')
                      style_col_plot = exp_config.get('plot_style_col', 'Injury_Day') # Corrected key
                      essential_plot_cols = [col for col in [hue_col_plot, style_col_plot] if col and col in aligned_metadata_for_plot.columns]

                      # Drop rows with NaN in essential plotting columns
                      original_count = len(aligned_metadata_for_plot)
                      aligned_metadata_for_plot = aligned_metadata_for_plot.dropna(subset=essential_plot_cols)
                      dropped_count = original_count - len(aligned_metadata_for_plot)
                      if dropped_count > 0:
                           print(f"   Warning: Dropping {dropped_count} ROIs with missing plotting metadata ({essential_plot_cols}).")

                      # Re-align composition matrix after dropping NaNs from metadata
                      composition_matrix_for_plot = composition_matrix_for_plot.loc[aligned_metadata_for_plot.index]

                      if len(aligned_metadata_for_plot) < 3:
                           print(f"   ERROR: Fewer than 3 ROIs remaining after handling missing plot metadata ({len(aligned_metadata_for_plot)}). Cannot plot ordination.")
                           aligned_metadata_for_plot = None # Prevent plotting
                           composition_matrix_for_plot = None

              except KeyError as ke:
                   print(f"ERROR aligning metadata for plot: Key error {ke}. Check metadata columns and composition index.")
                   aligned_metadata_for_plot = None # Prevent plotting
                   composition_matrix_for_plot = None
              except Exception as align_e:
                   print(f"ERROR during metadata alignment for plotting: {align_e}")
                   traceback.print_exc()
                   aligned_metadata_for_plot = None # Prevent plotting
                   composition_matrix_for_plot = None


         # Proceed with plotting if data is valid
         if composition_matrix_for_plot is not None and not composition_matrix_for_plot.empty and \
            aligned_metadata_for_plot is not None and not aligned_metadata_for_plot.empty:
             try:
                 distance_metric_plot = 'braycurtis' # Should match PERMANOVA typically
                 plot_filename = f"pcoa_{distance_metric_plot}_{grouping_col}_composition.png"
                 ordination_plot_path = os.path.join(vis_output_dir, plot_filename)

                 # Get plotting columns again, ensure they exist after potential drops
                 hue_col_plot = exp_config.get('plot_hue_col', 'Condition')
                 style_col_plot = exp_config.get('plot_style_col', 'Injury_Day')
                 hue_col_plot = hue_col_plot if hue_col_plot in aligned_metadata_for_plot.columns else None
                 style_col_plot = style_col_plot if style_col_plot in aligned_metadata_for_plot.columns else None

                 plot_ordination(
                     composition_matrix=composition_matrix_for_plot,
                     metadata_df=aligned_metadata_for_plot, # Pass the aligned and filtered metadata
                     config=config,
                     distance_metric=distance_metric_plot,
                     output_path=ordination_plot_path,
                     hue_col=hue_col_plot,
                     style_col=style_col_plot,
                     ordination_method='pcoa',
                     add_ellipse=True,
                     plot_dpi=plot_dpi
                 )
                 print(f"Ordination plot saved to: {ordination_plot_path}")
                 plt.close('all') # Close plot figure
             except Exception as plot_err:
                 print(f"ERROR: Failed to generate or save ordination plot: {plot_err}")
                 traceback.print_exc()
                 plt.close('all') # Ensure plot is closed on error
         else:
              print("Skipping ordination plot: No valid ROIs remaining after aligning metadata or composition matrix unavailable.")

    # 4. Abundance Trend Plots (New)
    if abundance_summary_df is not None:
        print("\n--- Generating Abundance Trend Visualizations ---")
        time_col = exp_config.get('timepoint_col')
        condition_col = exp_config.get('condition_col')
        replicate_col = exp_config.get('replicate_col') # Needed for lineplot SEM

        if time_col and condition_col:
            # Line Plot
            lineplot_filename = f"{grouping_col}_abundance_trend_lineplot.png"
            lineplot_path = os.path.join(vis_output_dir, lineplot_filename)
            try:
                plot_abundance_trends_lineplot(
                    abundance_summary_df=abundance_summary_df,
                    time_col=time_col,
                    condition_col=condition_col,
                    replicate_col=replicate_col, # Pass replicate column
                    grouping_col=grouping_col,
                    output_path=lineplot_path,
                    plot_dpi=plot_dpi
                )
            except Exception as e:
                print(f"ERROR generating abundance lineplot: {e}")
                traceback.print_exc()

            # Box Plot
            boxplot_filename = f"{grouping_col}_abundance_distribution_boxplot.png"
            boxplot_path = os.path.join(vis_output_dir, boxplot_filename)
            try:
                plot_abundance_distribution_boxplot(
                    abundance_summary_df=abundance_summary_df,
                    time_col=time_col,
                    condition_col=condition_col,
                    grouping_col=grouping_col,
                    output_path=boxplot_path,
                    plot_dpi=plot_dpi,
                    show_points=True # Optional: show individual points
                )
            except Exception as e:
                print(f"ERROR generating abundance boxplot: {e}")
                traceback.print_exc()
        else:
            print("Skipping abundance plots: 'timepoint_col' or 'condition_col' not defined in config.")
    else:
        print("\nSkipping abundance trend plots: Abundance summary data not available.")

    print("\n--- Experiment Visualization Generation Finished ---")


if __name__ == '__main__':
    config = load_config("config.yaml")
    if config:
        generate_visualizations(config)
    else:
        print("Exiting: Could not load configuration.")
        sys.exit(1) 